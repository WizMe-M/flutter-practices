# Практическая работа 1
## Тема: Вёрстка в фреймворке Flutter

**Цель работы**: закрепить знания синтаксиса языка Dart, закрепить навык вёрстки в фреймворке Flutter, закрепить знания стандартных виджетов Flutter, по необходимости изучить и применить новые виджеты в вёрстке, получить знания по подключению ассетов и шрифтов.  

Необходимо выбрать любые 3 экрана (на оценку 5) с дизайна из [Figma](https://www.figma.com/file/E0D9IHkPemq4Rd2tK9kFmw/Untitled?node-id=0%3A1) и сверстать экраны.  
Необязательно, чтобы в приложении можно было переключаться между этими экранами - достаточно менять их в _main.dart_ и делать **Hot Reload**/**Hot Restart**.

Помимо этого, экраны должны именоваться адекватно, как если бы это был настоящий проект.

---

## **Ход работы**
### Первый экран

Для разминки был выбран самый простой экран из доступных (экран [Welcome](https://www.figma.com/file/E0D9IHkPemq4Rd2tK9kFmw/Untitled?node-id=1%3A959))

По своей сути, это просто столбец элементов (изображений, текста и кнопок), поэтому непосредственно с разметкой проблем не было.  
Были опробованы два способа размещения элементов: через деление пространства виджетами `Expanded` и отделение виджетов друг от друга с помощью `Spacer`.

Изображения загружались через `Image.asset('assets/img-name.ext')`. Для этого была создана папка _assets_, в которую загружались все изображения. Для использования ассетов, необходимо в файлу с зависимостями (_pubspec.yaml_) добавить строки:
```
  assets:
    - assets-dir/
    - assets-dir/img-file.ext
```
где `assets` - ключевое слово, `assets-dir` - название папки с ассетами, а `img-file.ext` - название и расширение файла (изображения).

К сожалению, так изображение теряет качество. С чем связано не известно. Испрованые решения:
- Добавить в папку с ассетами подпапки, именующиеся '2.0x' и '3.0x' и туда разместить копии изображений. Каким-то образом должно использоваться изображение нужного разрешения без потери качества, но на деле изображение просто ужимается в размере
- Использовать параметр `fit:` с аргументами `BoxFit.fill` и `BoxFit.fitWidth`.  
    - fill - Растягивает изображение на всё доступное пространство;  
    - fitWidth - Растягивает изображение на всю доступную ширину, сохраняя пропорции;
- Использовать параметр `filterQuality:` с аргументом `FilterQuality.high`. Не реагирует на данный параметр.

Текст вставлялся максимально похожий   по размеру (_fontSize_) и по толщине (_fontWeight_)

Кнопки: две `ElevatedButton` и один `TextButton`:
1. Кнопка изначально немного более стилизована. Имеет возможности настройки эффектов от разных видов нажатий
2. Простая кнопка с прозрачным фоном (но в целом реагирует на нажатия также как и `ElevatedButton`). Имеет возможности для настройки текста

---

### Второй экран

Вторым экраном для вёрстки был выбран [Meditate](https://www.figma.com/file/E0D9IHkPemq4Rd2tK9kFmw/Untitled?node-id=1%3A523)

Размещение виджетов аналогично первому экрану (с использованием `Column`).

**Вариант 1** данного экрана:

Первый виджет - картинка с закругленными краями.  
Это просто `Image`, размещенный внутри `Container` с закругленными краями.
 
Дальше - стандартные виджеты `Text`. Первый и второй ориентированы _по левому краю_, третий - _по ширине_. FontWeight у всех разные. Для первого также использовался полупрозрачный черный цвет (`Colors.black38` - черный цвет с прозрачностью 38%).

Дальше идет уже знакомый виджет _ElevatedButton_, у которого был вызван метод `.icon()`.  
Он позволяет помимо одного дочернего виджета добавить еще и иконку. Иконка создаётся классом `Icon`, в который помещается один из `IconData` (есть заранее заготовленные варианты иконок из **MaterialDesign** -> класс `Icons.`).

Дальше был `ListView` (листаемый список элементов).  
По умолчанию, ListView просто список виджетов, который можно листать либо вертикально, либо горизонтально, и который содержит некоторые настройки пролистывания.  

Я же использовал `ListView.separated()`, который работает несколько иначе.  
Во-первых, был создан класс **Podcast** с полями имени, даты и цвета, после чего в `_MeditateScreenState` был добавлен список объектов этого класса.
Во-вторых, в `ListView.separated()` были добавлены обязательные аргументы: длина списка (itemCount), шаблон для элементов списка (itemBuilder - анонимная функция с аргументами **BuildContext** и **int**, где число - индекс элемента в списке), шаблон для разделителя элементов списка (separatorBuilder - аналогично предыдущему).

Т.к. ListView может бесконечно расширяться, а Column занимает всё доступное пространство для дочерних объектов, ListView внутри Column выбрасывает исключение.  
Решение: поместить ListView внутрь контейнера и задать ему явные размеры.

Недостатки этого решения:
1. Список на данном экране будет маленького размера, что неудобно и неинтуитивно (плохой **UX**)
2. Если увеличить высоту списка, то он уйдет за границы экрана. Можно, конечно, поместить Column в `SingleChildScrollView`, но так ListView будет перехватывать событие пролистывания экрана и не даст листать сам Column. (**ОЧЕНЬ плохой UX**)
3. Размер списка статичен и требует отдельных расчётов, если хотим сделать его динамическим (муторно)

------

Отсюда рождается **вариант 2** этого экрана.

Используем те же SingleChildScrollView вместе с Column, но список сделаем по другому.

Для данного решения воспользуемся **spread opeartor** (оператор три точки: "...").  
Как я понял, при компиляции он разворачивает некоторый список в перечисление его элементов через запятую.

Таким образом, можно подставить вместо List\<Podcast\> перечисление виджетов. Делается это следующим образом:

```
  ...podcasts.map((e) {
    return SomeWidget(...)
  }),
```
Написанный выше код сначала выполнит метод `.map()` (вместо каждого элемента `e` списка `podcasts` подставит виджет, т.е. создаст новый список), после чего **spread operator** развернет его в запись _"Widget1, Widget2, Widget3, ..., WidgetN"_.

В нашем случае, это тот же шаблон **itemBuilder**, но вместо использования `podcasts[index]` будет просто `e`, потому что это текущий элемент списка.

Единственнный минус данного решения - отсутствие встроенного разделителя (`Divider()`) из `ListView.separated(separatorBuilder: (ctx, index) => Divider())`, но и это при желании можно исправить.

---

### Третий экран

Третим экраном для вёрстки был выбран самый сложный (на мой взгляд) экран [iPhone 13 mini - 18](https://www.figma.com/file/E0D9IHkPemq4Rd2tK9kFmw/Untitled?node-id=1%3A870), т.к. он состоит из множества мелких и частых элементов.

Всё тот же Column и SingleChildScrollView (после недолгих раздумий о длине такого экрана был сделан вывод, что пытаться уместить всё сразу на одном экране, без пролистывания - глупо, т.к. он расчитан на длинный экран айфона, и не в тех же пропорциях будет выглядеть некрасиво).

Сходу кладём Column в контейнер с закругленными краями и немного более темным фоном.

В самом верху несколько наслаивающихся друг на друга элементов:

1. Изображение с круглыми краями
2. Некая дуга или сегмент круга
3. Кнопка с белой круглой границей

Исходя из этого, берем `Stack` с ориентацией дочерних элементов по центру снизу: `Stack(alignment: Alignment.bottomCenter)`.

Попробуем закруглить края изображения другим способом. Возьмем `ClipRRect` с тем же аргументом **borderRadius**, что и у Container, и внутрь положим изоражение.

Для дуги пришлось написать кастомный **painter**, который просто рисует дугу. Это _StatelessWidget_, у которого есть два параметра: ширина и высота.  
Чтобы она была чуть более похожа на ту дугу, что на дизайне в фигме, я сдвинул её виджетом `Positioned`.

С кнопкой всё проще. Это стилизованная ElevatedButton, которой в параметр **shape** был передан `CircleBorder`. Внутри кнопки - Icon.

Для текста пришлось скачать пакет шрифтов **Montserat**.  
Подключение шрифта аналогично использованию ассетов.  
**pubspec.yaml**:
```
 fonts:
    - family: Montserrat
      fonts:
        - asset: fonts/Montserrat-Black.ttf
          weight: 700 
        - asset: fonts/Montserrat-BlackItalic.ttf
          weight: 700
          style: italic 
```
Сначала указывается семейство шрифтов "**-family:**", затем пречисляются шрифты, указывая путь до них "**- asset: path/fontSome-name_type.ttf**".

Для изменения шрифта виджета Text, необходимо в `style: TextStyle()` указать параметр **fontFamily**.

После текста размещена стилизованная TextButton.

После идёт контейнер с закругленными краями (всеми!) и светло-фиолетовым цветом.  
Важный параметр - **clipBehavior** со значением Clip.hardEdge. Он нужен, чтобы дочерний контейнер снизу (темно-фиолетовый) тоже закруглил края по форме родителя.

В родительский контейнер кладём Column, в котором будет размещены несколько Row и `Spacer` (чтобы оставить немного пустого пространства).

Тут используется дополнительный (самописный) метод **avatar**:
```
avatar(double radius, {Color backgroundColor = Colors.orange, double borderWidth = 1, Color borderColor = Colors.black, String? text})
 ```
Он принимает обязательный аргумент radius, отвечающий за размер аватара, и необязательные (в их числе nullable String text).  
Логика данного метода: если text == null, то помещаем иконку по умолчнаию, в противном случае текст; остальные параметры для настройки вида и размера аватара; возвращает `CircleAvatar`, который обладает всем необходимым для отрисовки круглого аватара (нужно только передать параметры в конструктор класса).

Содержимое строк контейнера:  
- Весь текст - шрифт Montserrat.  
- Кнопки: TextButton (прямоугольные и полупрозрачные с текстом) и IconButton (там где иконки).
- Аватары - метод **avatar()**
- Пустое пространство - `Spacer()`

Последний элемент в столбце - это желтый закругленный контейнер с Row внутри.  
Он содержит Image, Text и IconButton.

---

## **Вывод**

В ходе выполнения данной работы были практикой закреплены знания синтаксиса Dart и стандартных виджетов, навыки вёрстки на Flutter, изучены и применены некоторые из неизученных виджетов (в их числе Icon, ListView, CircleAvatar), а также получены знания по подключению ассетов и шрифтов в приложении.  

Косвенно были получены знания о spread operator, выделено создание списков в отдельную переменную , закреплены знания по созданию новых классов на Dart, выделено создание аватаров (CircleAvatar) в отдельный метод с целью избавления от больших кусков повторяющегося кода (логики создания аватаров).